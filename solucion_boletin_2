___________________________________________________________________

EJERCICIO 1
___________________________________________________________________

##En parse_redr() sustituyo esto:
            case '<':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDONLY, 0, STDIN_FILENO);
                break;
            case '>':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDWR|O_CREAT, 0, STDOUT_FILENO);
                break;
            case '+': // >>
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDWR|O_CREAT, 0, STDOUT_FILENO);
                break;
##por esto:
            case '<':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDONLY, S_IRWXU, STDIN_FILENO);
                break;
            case '>':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU, STDOUT_FILENO);
                break;
            case '+': // >>
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_WRONLY|O_CREAT|O_APPEND, S_IRWXU, STDOUT_FILENO);
                break;

##En run_cmd() hay que cambiar esto:
	if ((fd = open(rcmd->file, rcmd->flags)) < 0)
        {
        	perror("open");
                exit(EXIT_FAILURE);
        }
##por esto:
	if ((fd = open(rcmd->file, rcmd->flags, rcmd->mode)) < 0)
        {
        	perror("open");
                exit(EXIT_FAILURE);
        }
___________________________________________________________________

EJERCICIO 2
___________________________________________________________________

#include <pwd.h>        para getpwuid()
#include <limits.h>     para PATH_MAX
#include <libgen.h>     para otras cosas

En «get_cmd»:

char* get_cmd()
{
    uid_t uid = getuid(); // Obtiene el uid
    struct passwd * passwd = getpwuid(uid); // Obtiene una entrada del fichero de cuentas del usuario

    // Con respecto a los errores es necesario tratar los mostrados en la sección "errores" de los manuales de las funciones.
    if (!passwd) {
            perror("getpwuid");
            exit(EXIT_FAILURE);
    }

    char * user = passwd -> pw_name; // Nombre del usuario sacado de la entrada

    char path[PATH_MAX];        // Ruta absoluta en el que se encuentra el usuario
                                // La constante reserva el espacio necesario para la máxima ruta posible

    if (!getcwd(path, PATH_MAX)) {
        perror("getcwd");
        exit(EXIT_FAILURE);
    }

    char * dir = basename(path); // Último directorio de la ruta absoluta

    char prompt[strlen(user) + strlen(dir) + 4]; // Reservar el espacio para el prompt
    // + 4 por el arroba, el mayor que, el espacio y el valor nulo.

    sprintf(prompt, "%s@%s> ", user, dir); // Almacena en el buffer la cadena del prompt

    char* buf;

    // Lee la orden tecleada por el usuario
    // ahora muestra el prompt
    buf = readline(prompt);

    // Si el usuario ha escrito una orden, almacenarla en la historia.
    if(buf)
        add_history(buf);

    return buf;
}

Es recomendable que código relacionado con los comandos internos esté implementado en funciones en aras de la legibilidad y la modularidad.

Tercer ejercicio:

Cuarto ejercicio:

Simplemente hay que liberar la memoria y ejecutar un exit.
