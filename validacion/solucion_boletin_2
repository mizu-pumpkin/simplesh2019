____________________________________________________________

EJERCICIO 1: Modifica simplesh para que los ficheros se creen con permisos 700 y la semántica de las redirecciones sea la misma que tendrían si se ejecutasen los comandos en bash. Para realizar el ejercicio, utiliza los flags y el mode de open().
____________________________________________________________

>>>Leerse man 2 open

>>>En parse_redr() sustituyo esto:
            case '<':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDONLY, 0, STDIN_FILENO);
                break;
            case '>':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDWR|O_CREAT, 0, STDOUT_FILENO);
                break;
            case '+': // >>
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDWR|O_CREAT, 0, STDOUT_FILENO);
                break;
>>>por esto:
            case '<':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_RDONLY, S_IRWXU, STDIN_FILENO);
                break;
            case '>':
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU, STDOUT_FILENO);
                break;
            case '+': // >>
                cmd = redrcmd(cmd, start_of_token, end_of_token, O_WRONLY|O_CREAT|O_APPEND, S_IRWXU, STDOUT_FILENO);
                break;

>>>En run_cmd() hay que cambiar esto:
	if ((fd = open(rcmd->file, rcmd->flags)) < 0)
        {
        	perror("open");
                exit(EXIT_FAILURE);
        }
>>>por esto:
	if ((fd = open(rcmd->file, rcmd->flags, rcmd->mode)) < 0)
        {
        	perror("open");
                exit(EXIT_FAILURE);
        }
____________________________________________________________

EJERCICIO 2: Modifica el prompt para que muestre el
usuario y el directorio de trabajo actual separados por el carácter @:
    usuario@directorio > ␣ ...
Para ello, únicamente se pueden usar llamadas POSIX o funciones de la biblioteca estándar de C (C11).
Llamadas POSIX y/o glibc a considerar:
    getuid()
    getpwuid()
    getcwd() (Versión POSIX sin extensiones GNU)
    basename() (Versión POSIX)
    sprintf()
____________________________________________________________

>>>Añadir esto:
#include <pwd.h>        //para getpwuid()
#include <limits.h>     //para PATH_MAX
#include <libgen.h>     //para otras cosas

>>>Cambiar esto:
char* get_cmd()
{
    char* buf;

    // Lee la orden tecleada por el usuario
    buf = readline("simplesh> ");

    // Si el usuario ha escrito una orden, almacenarla en la historia.
    if(buf)
        add_history(buf);

    return buf;
}
>>>Por esto:
char* get_cmd()
{
    uid_t uid = getuid(); // Obtiene el uid
    struct passwd * passwd = getpwuid(uid); // Obtiene una entrada del fichero de cuentas del usuario

    // Con respecto a los errores es necesario tratar los mostrados en la sección "errores" de los manuales de las funciones
    if (!passwd) {
            perror("getpwuid");
            exit(EXIT_FAILURE);
    }

    char * user = passwd->pw_name; // Nombre del usuario sacado de la entrada

    char path[PATH_MAX];        // Ruta absoluta en el que se encuentra el usuario

    if (!getcwd(path, PATH_MAX)) {
        perror("getcwd");
        exit(EXIT_FAILURE);
    }

    char * dir = basename(path); // Directorio en el que estamos sin la ruta absoluta

    char prompt[strlen(user) + strlen(dir) + 4]; // Reservar el espacio para el prompt
    // + 4 por el arroba, el mayor que, el espacio y el valor nulo

    sprintf(prompt, "%s@%s> ", user, dir); // Almacena en el buffer la cadena del prompt

    char* buf;

    // Lee la orden tecleada por el usuario
    buf = readline(prompt);

    // Si el usuario ha escrito una orden, almacenarla en la historia.
    if(buf)
        add_history(buf);

    return buf;
}

____________________________________________________________

EJERCICIO 3: Implementa el comando interno cwd:
    simplesh > cwd
    cwd : / ruta / a / directorio
Para ello, únicamente se pueden usar llamadas al sistema POSIX o funciones de la biblioteca estándar de C (C11).
Llamadas POSIX y/o glibc a considerar:
    getcwd() (Versión POSIX sin extensiones GNU)
Para implementar cwd, escribe la función run_cwd() e inserta
llamadas a la misma en simplesh.c donde sea necesario.
____________________________________________________________
1 Escribe la función run_cwd() respetando fielmente el enunciado
2 Verifica que la función run_cwd() funciona correctamente
3 Escribe una función que dado un comando, determine si es interno
4 Usa la función anterior para saber cuando llamar a run_cwd()
5 Analiza cada llamada a la función exec_cmd() dentro de run_cmd() para saber dónde hay que llamar a run_cwd(), para ejecutar el comando interno cwd, en lugar de llamar a exec_cmd()
6 Escribe e inserta llamadas a las funciones run_exit() y run_cd() siguiendo la misma estrategia que con run_cwd()
7 Asegúrate de que los tres comandos internos del boletín exhiben el comportamiento esperado con ./simplesh.py -i boletin2.json
8 Comprueba que no hay fugas de memoria con ./valgrind.sh
____________________________________________________________

EJERCICIO 4: Implementa el comando interno exit:
    simplesh > exit
    [ bash ]
Para ello, únicamente se pueden usar llamadas al sistema POSIX o funciones de la biblioteca estándar de C (C11).
Llamadas POSIX y/o glibc a considerar: exit
Para implementar exit, escribe la función run_exit() e inserta llamadas a la misma en simplesh.c donde sea necesario. Nótese que exit sólo termina el proceso que ejecuta la llamada.
Verifica que simplesh finaliza siempre que encuentra el comando interno exit (el segundo echo no se ejecuta):
    simplesh > echo 1 ; exit ; echo 2
    [ bash ]
Comprueba que tras ejecutar exit se libera toda la memoria
____________________________________________________________

El comportamiento de simplesh cuando se ejecuta cualquiera de los comandos internos tiene que ser similar al de bash en estos casos:
    simplesh > echo 1; exit ; echo 2
    1
    [ bash ]
    # El comando "echo 2" no se ejecuta.
    
    simplesh > echo 1 | exit
    simplesh >
    # El comando "echo 1" se ejecuta pero su salida es ignorada por "exit".
    # El comando "exit" se ejecuta pero simplesh no finaliza su ejecución.
    
    simplesh > exit &
    simplesh >
    
    simplesh > ( exit )
    simplesh >
    # El comando "exit" se ejecuta pero simplesh no finaliza su ejecución.
//TODO    
    simplesh > exit > salida
    [ bash ]
    # La salida de "exit" se redirige al fichero salida que se crea con tamaño cero.
    # Se requiere el uso de llamadas para manipulación de descriptores de fichero.
____________________________________________________________

EJERCICIO 5(a): Implementa el comando interno cd dir:
    simplesh > cwd
    cwd : / home / usuario
    simplesh > cd directorio
    simplesh > cwd
    cwd : / home / usuario / directorio
Para ello, únicamente se pueden usar llamadas al sistema POSIX o funciones de la biblioteca estándar de C (C11).
Llamadas POSIX y/o glibc a considerar: chdir()
Para implementar cd, escribe la función run_cd() e inserta
llamadas a la misma en simplesh.c donde sea necesario.
Nótese que chdir() sólo cambia el directorio actual del proceso que ejecuta la llamada.
Verifica que simplesh modifica el directorio actual siempre que encuentra el comando interno cd:
    simplesh > cwd ; cd directorio ; cwd ; cd .. ; cwd
    cwd : / home / usuario
    cwd : / home / usuario / directorio
    cwd : / home / usuario
____________________________________________________________

____________________________________________________________

EJERCICIO 5 (b): Implementa el comando interno cd [-]:
    simplesh > cd -
    run_cd : Variable OLDPWD no definida
    simplesh > cwd
    cwd : / home / usuario / directorio
    simplesh > cd
    simplesh > cwd
    cwd : / home / usuario
    simplesh > cd -
    simplesh > cwd
    cwd : / home / usuario / directorio
El directorio por defecto es el valor de la variable de entorno HOME, mientras que OLDPWD contiene el directorio de trabajo previo (NB: Cuando se inicia simplesh, se debe eliminar la variable de entorno OLDPWD. Sólo tras la ejecución con éxito del primer comando interno cd, se definirá la variable OLDPWD con el directorio de trabajo inicial. A partir de entonces, la variable OLDPWD se
actualizará cada vez que se ejecute con éxito el comando interno cd, asignándole el directorio de trabajo previo.)
Llamadas POSIX y/o glibc a considerar: getcwd(), getenv(),
setenv() y unsetenv()
Verifica que simplesh modifica el directorio actual siempre que encuentra el comando interno cd:
    simplesh > cwd ; cd ; cwd ; cd - ; cwd
    cwd : / home / usuario / directorio
    cwd : / home / usuario
    cwd : / home / usuario / directorio
____________________________________________________________

